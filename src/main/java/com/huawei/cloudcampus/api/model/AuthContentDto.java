/*
 * AP SSID配置管理
 * AP SSID第三方接口。
 *
 * OpenAPI spec version: 1.4.1
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */


package com.huawei.cloudcampus.api.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import com.huawei.cloudcampus.api.model.PortalContentDto;
import com.huawei.cloudcampus.api.model.RadiusContentDto;
import io.swagger.annotations.ApiModel;
import io.swagger.annotations.ApiModelProperty;
import java.io.IOException;

/**
 * SSID认证方式。
 */
@ApiModel(description = "SSID认证方式。")
@javax.annotation.Generated(value = "io.swagger.codegen.languages.JavaSdnClientCodegen", date = "2019-12-17T15:18:17.238+08:00")
public class AuthContentDto {
  /**
   * 关联SSID时的认证模式。
   */
  @JsonAdapter(ModeEnum.Adapter.class)
  public enum ModeEnum {
    OPEN("open"),
    
    PSK("psk"),
    
    PPSK("ppsk"),
    
    DOT1X("dot1x"),
    
    MAC("mac");

    private String value;

    ModeEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static ModeEnum fromValue(String text) {
      for (ModeEnum b : ModeEnum.values()) {
        if (String.valueOf(b.value).equals(text)) {
          return b;
        }
      }
      return null;
    }

    public static class Adapter extends TypeAdapter<ModeEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final ModeEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public ModeEnum read(final JsonReader jsonReader) throws IOException {
        String value = jsonReader.nextString();
        return ModeEnum.fromValue(String.valueOf(value));
      }
    }
  }

  @SerializedName("mode")
  private ModeEnum mode = null;

  /**
   * 加密模式，当mode为psk或ppsk时必选。大小写敏感，前后不能有空格，且不能含有全角字符。当mode为ppsk时加密方式不支持wep。
   */
  @JsonAdapter(PskEncryptTypeEnum.Adapter.class)
  public enum PskEncryptTypeEnum {
    WEP("wep"),
    
    WPA1ANDWPA2("wpa1AndWpa2"),
    
    WPA2("wpa2");

    private String value;

    PskEncryptTypeEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static PskEncryptTypeEnum fromValue(String text) {
      for (PskEncryptTypeEnum b : PskEncryptTypeEnum.values()) {
        if (String.valueOf(b.value).equals(text)) {
          return b;
        }
      }
      return null;
    }

    public static class Adapter extends TypeAdapter<PskEncryptTypeEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final PskEncryptTypeEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public PskEncryptTypeEnum read(final JsonReader jsonReader) throws IOException {
        String value = jsonReader.nextString();
        return PskEncryptTypeEnum.fromValue(String.valueOf(value));
      }
    }
  }

  @SerializedName("pskEncryptType")
  private PskEncryptTypeEnum pskEncryptType = null;

  @SerializedName("securityKey")
  private String securityKey = null;

  /**
   * wpa2加密方法，当pskEncryptType为wpa2时必选，默认值为AES。大小写敏感，前后不能有空格，且不能含有全角字符。
   */
  @JsonAdapter(SecurityKeyTypeEnum.Adapter.class)
  public enum SecurityKeyTypeEnum {
    AES("AES"),
    
    AES_TKIP("AES-TKIP"),
    
    TKIP("TKIP");

    private String value;

    SecurityKeyTypeEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static SecurityKeyTypeEnum fromValue(String text) {
      for (SecurityKeyTypeEnum b : SecurityKeyTypeEnum.values()) {
        if (String.valueOf(b.value).equals(text)) {
          return b;
        }
      }
      return null;
    }

    public static class Adapter extends TypeAdapter<SecurityKeyTypeEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final SecurityKeyTypeEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public SecurityKeyTypeEnum read(final JsonReader jsonReader) throws IOException {
        String value = jsonReader.nextString();
        return SecurityKeyTypeEnum.fromValue(String.valueOf(value));
      }
    }
  }

  @SerializedName("securityKeyType")
  private SecurityKeyTypeEnum securityKeyType = null;

  /**
   * dot1x加密模式，当mode为dot1x时必选。大小写敏感，前后不能有空格，且不能含有全角字符。
   */
  @JsonAdapter(Dot1xEncryptTypeEnum.Adapter.class)
  public enum Dot1xEncryptTypeEnum {
    WPA1ANDWPA2("wpa1AndWpa2"),
    
    WPA2("wpa2");

    private String value;

    Dot1xEncryptTypeEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static Dot1xEncryptTypeEnum fromValue(String text) {
      for (Dot1xEncryptTypeEnum b : Dot1xEncryptTypeEnum.values()) {
        if (String.valueOf(b.value).equals(text)) {
          return b;
        }
      }
      return null;
    }

    public static class Adapter extends TypeAdapter<Dot1xEncryptTypeEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final Dot1xEncryptTypeEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public Dot1xEncryptTypeEnum read(final JsonReader jsonReader) throws IOException {
        String value = jsonReader.nextString();
        return Dot1xEncryptTypeEnum.fromValue(String.valueOf(value));
      }
    }
  }

  @SerializedName("dot1xEncryptType")
  private Dot1xEncryptTypeEnum dot1xEncryptType = null;

  @SerializedName("portal")
  private PortalContentDto portal = null;

  @SerializedName("radius")
  private RadiusContentDto radius = null;

  @SerializedName("macAutoBinding")
  private Boolean macAutoBinding = null;

  /**
   * 逃生策略。当mode为ppsk时，此参数必填。 noNew：允许已认证用户继续使用网络，新用户不允许接入。默认值。 noAuth：允许已认证用户继续使用网络，新用户需要输入PPSK密钥。注意：此时PPSK用户数控制、MCA自动绑定功失效。 
   */
  @JsonAdapter(EscapeStrategyEnum.Adapter.class)
  public enum EscapeStrategyEnum {
    NONEW("noNew"),
    
    NOAUTH("noAuth");

    private String value;

    EscapeStrategyEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static EscapeStrategyEnum fromValue(String text) {
      for (EscapeStrategyEnum b : EscapeStrategyEnum.values()) {
        if (String.valueOf(b.value).equals(text)) {
          return b;
        }
      }
      return null;
    }

    public static class Adapter extends TypeAdapter<EscapeStrategyEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final EscapeStrategyEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public EscapeStrategyEnum read(final JsonReader jsonReader) throws IOException {
        String value = jsonReader.nextString();
        return EscapeStrategyEnum.fromValue(String.valueOf(value));
      }
    }
  }

  @SerializedName("escapeStrategy")
  private EscapeStrategyEnum escapeStrategy = null;

  public AuthContentDto mode(ModeEnum mode) {
    this.mode = mode;
    return this;
  }

   /**
   * 关联SSID时的认证模式。
   * return mode
  **/
  @ApiModelProperty(required = true, value = "关联SSID时的认证模式。")
  public ModeEnum getMode() {
    return mode;
  }

   /**
   * 关联SSID时的认证模式。
   * Param mode
  **/
  public void setMode(ModeEnum mode) {
    this.mode = mode;
  }

  public AuthContentDto pskEncryptType(PskEncryptTypeEnum pskEncryptType) {
    this.pskEncryptType = pskEncryptType;
    return this;
  }

   /**
   * 加密模式，当mode为psk或ppsk时必选。大小写敏感，前后不能有空格，且不能含有全角字符。当mode为ppsk时加密方式不支持wep。
   * return pskEncryptType
  **/
  @ApiModelProperty(value = "加密模式，当mode为psk或ppsk时必选。大小写敏感，前后不能有空格，且不能含有全角字符。当mode为ppsk时加密方式不支持wep。")
  public PskEncryptTypeEnum getPskEncryptType() {
    return pskEncryptType;
  }

   /**
   * 加密模式，当mode为psk或ppsk时必选。大小写敏感，前后不能有空格，且不能含有全角字符。当mode为ppsk时加密方式不支持wep。
   * Param pskEncryptType
  **/
  public void setPskEncryptType(PskEncryptTypeEnum pskEncryptType) {
    this.pskEncryptType = pskEncryptType;
  }

  public AuthContentDto securityKey(String securityKey) {
    this.securityKey = securityKey;
    return this;
  }

   /**
   * psk密钥，当mode为psk时必选。查询始终为null。 当pskEncryptType为wep时，5位字符与数字组合的字符串。 当pskEncryptType为wpa1AndWpa2或wpa2时，8-63位字母、数字及除问号与空格外的特殊字符组合。
   * return securityKey
  **/
  @ApiModelProperty(value = "psk密钥，当mode为psk时必选。查询始终为null。 当pskEncryptType为wep时，5位字符与数字组合的字符串。 当pskEncryptType为wpa1AndWpa2或wpa2时，8-63位字母、数字及除问号与空格外的特殊字符组合。")
  public String getSecurityKey() {
    return securityKey;
  }

   /**
   * psk密钥，当mode为psk时必选。查询始终为null。 当pskEncryptType为wep时，5位字符与数字组合的字符串。 当pskEncryptType为wpa1AndWpa2或wpa2时，8-63位字母、数字及除问号与空格外的特殊字符组合。
   * Param securityKey
  **/
  public void setSecurityKey(String securityKey) {
    this.securityKey = securityKey;
  }

  public AuthContentDto securityKeyType(SecurityKeyTypeEnum securityKeyType) {
    this.securityKeyType = securityKeyType;
    return this;
  }

   /**
   * wpa2加密方法，当pskEncryptType为wpa2时必选，默认值为AES。大小写敏感，前后不能有空格，且不能含有全角字符。
   * return securityKeyType
  **/
  @ApiModelProperty(value = "wpa2加密方法，当pskEncryptType为wpa2时必选，默认值为AES。大小写敏感，前后不能有空格，且不能含有全角字符。")
  public SecurityKeyTypeEnum getSecurityKeyType() {
    return securityKeyType;
  }

   /**
   * wpa2加密方法，当pskEncryptType为wpa2时必选，默认值为AES。大小写敏感，前后不能有空格，且不能含有全角字符。
   * Param securityKeyType
  **/
  public void setSecurityKeyType(SecurityKeyTypeEnum securityKeyType) {
    this.securityKeyType = securityKeyType;
  }

  public AuthContentDto dot1xEncryptType(Dot1xEncryptTypeEnum dot1xEncryptType) {
    this.dot1xEncryptType = dot1xEncryptType;
    return this;
  }

   /**
   * dot1x加密模式，当mode为dot1x时必选。大小写敏感，前后不能有空格，且不能含有全角字符。
   * return dot1xEncryptType
  **/
  @ApiModelProperty(value = "dot1x加密模式，当mode为dot1x时必选。大小写敏感，前后不能有空格，且不能含有全角字符。")
  public Dot1xEncryptTypeEnum getDot1xEncryptType() {
    return dot1xEncryptType;
  }

   /**
   * dot1x加密模式，当mode为dot1x时必选。大小写敏感，前后不能有空格，且不能含有全角字符。
   * Param dot1xEncryptType
  **/
  public void setDot1xEncryptType(Dot1xEncryptTypeEnum dot1xEncryptType) {
    this.dot1xEncryptType = dot1xEncryptType;
  }

  public AuthContentDto portal(PortalContentDto portal) {
    this.portal = portal;
    return this;
  }

   /**
   * Get portal
   * return portal
  **/
  @ApiModelProperty(value = "")
  public PortalContentDto getPortal() {
    return portal;
  }

   /**
   * Set portal
   * Param portal
  **/
  public void setPortal(PortalContentDto portal) {
    this.portal = portal;
  }

  public AuthContentDto radius(RadiusContentDto radius) {
    this.radius = radius;
    return this;
  }

   /**
   * Get radius
   * return radius
  **/
  @ApiModelProperty(value = "")
  public RadiusContentDto getRadius() {
    return radius;
  }

   /**
   * Set radius
   * Param radius
  **/
  public void setRadius(RadiusContentDto radius) {
    this.radius = radius;
  }

  public AuthContentDto macAutoBinding(Boolean macAutoBinding) {
    this.macAutoBinding = macAutoBinding;
    return this;
  }

   /**
   * 是否MAC自动绑定。当mode为ppsk时，此参数必填。若值为true，则开启MAC自动绑定。
   * return macAutoBinding
  **/
  @ApiModelProperty(value = "是否MAC自动绑定。当mode为ppsk时，此参数必填。若值为true，则开启MAC自动绑定。")
  public Boolean getMacAutoBinding() {
    return macAutoBinding;
  }

   /**
   * 是否MAC自动绑定。当mode为ppsk时，此参数必填。若值为true，则开启MAC自动绑定。
   * Param macAutoBinding
  **/
  public void setMacAutoBinding(Boolean macAutoBinding) {
    this.macAutoBinding = macAutoBinding;
  }

  public AuthContentDto escapeStrategy(EscapeStrategyEnum escapeStrategy) {
    this.escapeStrategy = escapeStrategy;
    return this;
  }

   /**
   * 逃生策略。当mode为ppsk时，此参数必填。 noNew：允许已认证用户继续使用网络，新用户不允许接入。默认值。 noAuth：允许已认证用户继续使用网络，新用户需要输入PPSK密钥。注意：此时PPSK用户数控制、MCA自动绑定功失效。 
   * return escapeStrategy
  **/
  @ApiModelProperty(value = "逃生策略。当mode为ppsk时，此参数必填。 noNew：允许已认证用户继续使用网络，新用户不允许接入。默认值。 noAuth：允许已认证用户继续使用网络，新用户需要输入PPSK密钥。注意：此时PPSK用户数控制、MCA自动绑定功失效。 ")
  public EscapeStrategyEnum getEscapeStrategy() {
    return escapeStrategy;
  }

   /**
   * 逃生策略。当mode为ppsk时，此参数必填。 noNew：允许已认证用户继续使用网络，新用户不允许接入。默认值。 noAuth：允许已认证用户继续使用网络，新用户需要输入PPSK密钥。注意：此时PPSK用户数控制、MCA自动绑定功失效。 
   * Param escapeStrategy
  **/
  public void setEscapeStrategy(EscapeStrategyEnum escapeStrategy) {
    this.escapeStrategy = escapeStrategy;
  }


  @Override
  public boolean equals(java.lang.Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    AuthContentDto authContentDto = (AuthContentDto) o;
    return Objects.equals(this.mode, authContentDto.mode) &&
        Objects.equals(this.pskEncryptType, authContentDto.pskEncryptType) &&
        Objects.equals(this.securityKey, authContentDto.securityKey) &&
        Objects.equals(this.securityKeyType, authContentDto.securityKeyType) &&
        Objects.equals(this.dot1xEncryptType, authContentDto.dot1xEncryptType) &&
        Objects.equals(this.portal, authContentDto.portal) &&
        Objects.equals(this.radius, authContentDto.radius) &&
        Objects.equals(this.macAutoBinding, authContentDto.macAutoBinding) &&
        Objects.equals(this.escapeStrategy, authContentDto.escapeStrategy);
  }

  @Override
  public int hashCode() {
    return Objects.hash(mode, pskEncryptType, securityKey, securityKeyType, dot1xEncryptType, portal, radius, macAutoBinding, escapeStrategy);
  }


  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class AuthContentDto {\n");
    
    sb.append("    mode: ").append(toIndentedString(mode)).append("\n");
    sb.append("    pskEncryptType: ").append(toIndentedString(pskEncryptType)).append("\n");
    sb.append("    securityKey: ").append(toIndentedString(securityKey)).append("\n");
    sb.append("    securityKeyType: ").append(toIndentedString(securityKeyType)).append("\n");
    sb.append("    dot1xEncryptType: ").append(toIndentedString(dot1xEncryptType)).append("\n");
    sb.append("    portal: ").append(toIndentedString(portal)).append("\n");
    sb.append("    radius: ").append(toIndentedString(radius)).append("\n");
    sb.append("    macAutoBinding: ").append(toIndentedString(macAutoBinding)).append("\n");
    sb.append("    escapeStrategy: ").append(toIndentedString(escapeStrategy)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(java.lang.Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }

}

